<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jacy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jacy">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jacy">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Jacy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.gif">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xl01i.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jacy</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://d.weibo.com/" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="http://www.163.com/rss/" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/#signin" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/娱乐/" style="font-size: 15px;">娱乐</a> <a href="/tags/娱乐-经验/" style="font-size: 10px;">娱乐+经验</a> <a href="/tags/经验/" style="font-size: 20px;">经验</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://huangweijie.github.io/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">慢慢前行。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Jacy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xl01i.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Jacy</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://d.weibo.com/" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="http://www.163.com/rss/" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/#signin" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-谈谈自家的许愿墙" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/14/谈谈自家的许愿墙/" class="article-date">
  	<time datetime="2017-03-14T08:59:01.958Z" itemprop="datePublished">2017-03-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/谈谈自家的许愿墙/">谈谈自家的许愿墙</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>有个词语挺有意思的，叫老生常谈，顾名思议，老书生经常谈（虽然原意为老书生经常说的话），看来我也要成为老书生了，竟是谈~来回归正题，我们来谈谈自家的许愿墙。</p>
</blockquote>
<h2 id="项目背景">项目背景</h2><p>广工大学城校区是典型的阳盛阴衰的，每年的女生节在广工算是一个比较隆重的节目了吧，为了让女生享受到更加便利的关注，为了让更多的男生女生们参与进大学丰富多彩的活动中，许愿墙就诞生了，并传承至今。</p>
<h2 id="项目简介">项目简介</h2><p>1.许愿墙在去年是开发成为微信的web app，相比往年增加了游戏这个新功能（虽然反响并不是特别好(┬＿┬)）。<br>2.我们团队先从项目需求入手进行分析，广工的背景让这个项目的生命周期在每年可以持续一周左右，除了提供基本的女生许愿男生领取愿望功能外，我们还希望加入一些新的元素吸引更多的人关注，类似接金币游戏就此诞生，画面展现出了男女生们的青春活力。<br>3.另外在这里不得不提提我们的暗恋匹配功能啦，大家写下心目中的他（她），若双方互相暗恋，就能告知对方，成就了数对小情侣们，成功牵线是我们的骄傲，是我们的自豪o(∩_∩)o。<br>4.考虑到保护女生们的信息安全问题，我们采取微信授权认证，只有男生领取了女生的愿望，才能获取女生相关信息，让他们能够进行交流而实现愿望。<br>5.项目在前端采用react+mobx+es6，引用gulp-webpack构建打包，后台使用nodejs+express构建，并使用mongo数据库存储相关信息数据（别想偷信息哈）。</p>
<h2 id="技术介绍">技术介绍</h2><h3 id="前端"><strong>前端</strong></h3><p><strong>React：</strong><br>要问到前端方面为什么选用react呢，而不用轻量级vue和boss级angular呢，挑选技术栈时它们确实一直在向我们招手，都想要朕重用它们😄，vue虽然用的特别的舒服，style+template+javascript组成一个vue文件，每一个都那么的清晰，用的那么舒服，可是在前面做过几个项目都用的vue，这次我们想多接触下别的框架，扩宽知识广度，而angular相对比较适合大型应用，使用脏检测的方式跟踪更新数据，在不熟悉的情况下使用会有比较多的坑，因此我们还是选择了也比较热门的react进行开发。<br>react的virtual DOM（虚拟DOM）使得项目可以不用直接操作DOM，而是通过虚拟的DOM进行操作，然后经过改进的diff算法计算后，通过render函数进行更新，大大提高了项目的性能。<br>来来来，我们来了解了解react的virtual DOM是怎么回事，virtual DOM把原生的DOM进行了抽象，在生成页面的时候会同时产生原生DOM的副本，我们在js的操作是先对副本进行操作，然后使用diff算法对比，对发生变化的部分进行自动更新（也可以人为控制生命周期）而不用全部重新渲染。<br>传统的DOM diff算法是通过遍历节点实现的，算法复杂度达到了O(n^3)，指数型的算法复杂度在节点数多的时候效率是特别的低的，而react通过3个策略改进了diff算法，使其复杂度仅为O(n)，大大提高了计算速度。<br><strong>React diff策略：</strong></p>
<ol>
<li>在web UI中DOM节点的跨层级操作是特别少的，基本可以忽略不计。</li>
<li>相同组件有相似的结构，不同组件有不同的结构。</li>
<li>对同一层次的节点可以通过唯一的id进行区分。</li>
</ol>
<p><strong>第一点(tree diff)</strong><br>由于跨层级操作少，可以只对两棵树进行同层对比，当发现某一层次节点不存在或者新增了，则新增该节点或者删除该节点及其子节点（不会再对子节点进行比较）。<br>但是当出现跨层级的移动操作，React diff就会对已经不存在节点直接删除，而对新存在的节点进行新增，而不是直接通过移动实现，这样就会影响性能，所以还是需要尽量避免进行跨层级的操作。</p>
<p><strong>第二点(component diff)</strong><br>React diff在发现相同的组件时就会进行tree diff比较，而不同的组件则直接删除更换，不会再进行进一步的比较，这又通过节省diff计算大大提高了计算速度，当然用户可以通过shouldComponentUpdate()返回true还是false来自己决定是否对该组件及其子组件进行更新。</p>
<p><strong>第三点（element diff）</strong><br>React diff在同层次发现不同节点直接就删除替换了，那么有没可能只是顺序的不同，而只是调换一下顺序呢，当然有~<br>所以通过给节点标上唯一的id，那么节点就能通过对比新老集合的位置，只进行移动，而不需要进行删除及创建插入，这样就能更高效的进行更新了。</p>
<p>以上只是个人看了相关内容后的理解总结，有什么不对的可以评论改进喔~<br>在此留下收藏的资料供大家看：<br><a href="https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender" target="_blank" rel="external">React源码解析+diff算法</a><br><a href="https://supnate.github.io/react-dom-diff/index.html" target="_blank" rel="external">github自己体会下diff算法（打开控制台观看）</a></p>
<p><strong>mobx：</strong><br>对于mobx的了解倒还不是特别的深，稍微了解了下mobx和redux的区别，redux是有action，store和view三层，通过reducer修改数据后经过双向数据绑定达到更新试图的目的，但是redux会出现多订阅，粗粒度的缺点，比如：<br>if(c) {<br>    return a;<br>}<br>return b;<br>这时候会对a,b,c都进行监听，然而在c为true的时候，b就没有进行使用了；<br>粗粒度则是在只对arr[0].name进行了修改引用，而监听是针对的arr的；<br>由于许愿墙只需要进行store到view层的操作对使用的用户数据进行存储，因此采用mobx相对比较小，学习使用成本也相对比较低，通过es6的修饰器引入mobx的observable接口，在所有页面共享该用户的数据，减少各个页面对用户数据的传递导致组件的更新或者因此而导致的增加http请求。</p>
<p><strong>gulp-webpack:</strong><br>使用gulp进行本地的调试开发，自动更新页面大大提高了开发的效率，通过webpack引入css-loader、style-loader、url-loader分别对css的url进行支持，对css进行支持，对图片url进行支持，还引入postcss-loader（autoprefixer插件）自动增加css前缀适配多端，另外当然是引入babel-preset-es2015,babel-preset-react和babel-preset-stage-num(0~3)对es6进行解析。</p>
<h3 id="后台"><strong>后台</strong></h3><p>后台使用nodejs+express框架开启服务器，通过express监听各个请求，设置路由专门处理相应的请求，另外在对数据库的操作再另外设置一个代理，路由中通过代理对数据库进行操作后作出请求的相应。<br>后台还需要通过引入bodyparser，cookieparser来对body json数据以及cookie进行解析使用。</p>
<h2 id="问题汇总">问题汇总</h2><p>1.首先感受最深刻的就是游戏性能问题的，由于首次接触canvas的游戏开发，对性能的研究基本没有，在掉落“金币”时的掉落动画会有些许卡顿，体验极其不友好。<br><strong>改进：</strong>通过相关研究，在掉落“金币”时，对其对象进行重复利用，通过循环产生的“金币”，在经过下降后由于“金币”会消失在视图中，通过设置一定数量上限让“金币”达到上限时再重新从0开始赋予“金币”属性。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">chansheng</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> <span class="params">(shi % h == <span class="number">0</span>)</span> {
        <span class="keyword">for</span> <span class="params">(var j = <span class="number">2</span> * chi; j &lt; <span class="number">2</span> * <span class="params">(chi + <span class="number">1</span>)</span>; j++)</span> {
            tu[j] = new object<span class="params">()</span>;
            ...
            var range = canvasW - w <span class="built_in">*</span> B;
            var i = Math.<span class="built_in">round</span><span class="params">(Math.random<span class="params">()</span> * range)</span>;
            <span class="keyword">if</span> <span class="params">(j == <span class="number">2</span> * chi + <span class="number">1</span>)</span> {
                while <span class="params">(Math.abs<span class="params">(i - tu[<span class="number">2</span> * chi].x)</span> &lt; w * B)</span> {
                    i = Math.<span class="built_in">round</span><span class="params">(Math.random<span class="params">()</span> * range)</span>;
                }
            }
            tu[j].x = i;
            tu[j].y = -Math.<span class="built_in">round</span><span class="params">(Math.random<span class="params">()</span> * <span class="number">100</span>)</span>;
        }
        chi++;
        <span class="keyword">if</span> <span class="params">(chi == <span class="number">50</span>)</span> chi = <span class="number">0</span>;  <span class="comment">//重置数量</span>
    }
    shi++;
}
</code></pre><p>2.在性能的优化方面还有就是可以通过缓存图像进行提高性能。<br><strong>改进：</strong></p>
<pre><code><span class="atom">var</span> <span class="atom">cacheCanvas</span> = [],
    <span class="atom">cacheCtx</span> = [],
    <span class="atom">down</span> = [];
<span class="atom">for</span> (<span class="atom">var</span> <span class="atom">i</span> = <span class="number">0</span>; <span class="atom">i</span> &lt;= <span class="number">4</span>; <span class="atom">i</span>++) {
    <span class="atom">down</span>[<span class="atom">i</span>] = <span class="atom">new</span> <span class="name">Image</span>();
}
<span class="atom">down</span>[<span class="number">0</span>].<span class="atom">src</span> = <span class="string">'images/down/boy.png'</span>;
<span class="atom">down</span>[<span class="number">1</span>].<span class="atom">src</span> = <span class="string">'images/down/+1s.png'</span>;
<span class="atom">down</span>[<span class="number">2</span>].<span class="atom">src</span> = <span class="string">'images/down/+10KG.png'</span>;
<span class="atom">down</span>[<span class="number">3</span>].<span class="atom">src</span> = <span class="string">'images/down/special.png'</span>;
<span class="atom">down</span>[<span class="number">4</span>].<span class="atom">src</span> = <span class="string">'images/down/love.png'</span>;
<span class="atom">for</span> (<span class="atom">var</span> <span class="atom">i</span> = <span class="number">0</span>; <span class="atom">i</span> &lt;= <span class="number">4</span>; <span class="atom">i</span>++) {
    <span class="atom">down</span>[<span class="atom">i</span>].<span class="atom">onload</span> = <span class="atom">function</span>() {
        <span class="atom">for</span> (<span class="atom">var</span> <span class="atom">i</span> = <span class="number">0</span>; <span class="atom">i</span> &lt;= <span class="number">4</span>; <span class="atom">i</span>++) {
            <span class="atom">cacheCanvas</span>[<span class="atom">i</span>] = <span class="atom">document</span>.<span class="atom">createElement</span>(<span class="string">'canvas'</span>);  //创建多个<span class="atom">canvas</span>元素把图片预先缓存，需要时再取出
            <span class="atom">cacheCtx</span>[<span class="atom">i</span>] = <span class="atom">cacheCanvas</span>[<span class="atom">i</span>].<span class="atom">getContext</span>(<span class="string">'2d'</span>);
            <span class="atom">cacheCanvas</span>[<span class="atom">i</span>].<span class="atom">width</span> = <span class="atom">down</span>[<span class="atom">i</span>].<span class="atom">width</span> * <span class="name">B</span>;
            <span class="atom">cacheCanvas</span>[<span class="atom">i</span>].<span class="atom">height</span> = <span class="atom">down</span>[<span class="atom">i</span>].<span class="atom">height</span> * <span class="name">B</span>;
            <span class="atom">cacheCtx</span>[<span class="atom">i</span>].<span class="atom">drawImage</span>(<span class="atom">down</span>[<span class="atom">i</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="atom">down</span>[<span class="atom">i</span>].<span class="atom">width</span> * <span class="name">B</span>, <span class="atom">down</span>[<span class="atom">i</span>].<span class="atom">height</span> * <span class="name">B</span>)
        }
    }
}
</code></pre><p>3.游戏在ios和安卓的适配方面出现了两个问题，一是在ios上iframe标签无法正常工作，二是ios9+的重力感应deviceorientation事件触发频率不同。<br><strong>改进：</strong> iframe标签无法工作后统一使用外链的形式，由于男女进入的游戏是不同版本的，在react的jsx中先判断用户性别，后使用跳转的方式进入游戏。由于触发频率的不同，导致ios9+与其他用户的移动速度不同，ios9+会比较快，造成不公平现象，于是采用加入时间验证的方式使游戏相对公平。</p>
<pre><code><span class="keyword">var</span> timeControl = <span class="keyword">new</span> <span class="built_in">Date</span>();  <span class="comment">//记录一次触发时间</span>
<span class="built_in">window</span>.addEventListener(<span class="string">"deviceorientation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{
    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - timeControl &gt;= <span class="number">30</span>) {   <span class="comment">//时间相隔大于等于30ms再触发</span>
        <span class="keyword">var</span> move = event.gamma;
        <span class="keyword">if</span> (move &lt; <span class="number">0</span>) {
            sprite.x = sprite.x - moveSpeed;
        } <span class="keyword">else</span> <span class="keyword">if</span> (move &gt; <span class="number">0</span>) {
            sprite.x = sprite.x + moveSpeed;
        }
        <span class="keyword">if</span> (sprite.x + playerWidth &gt;= canvasW) sprite.x = canvasW - playerWidth;
        <span class="keyword">else</span> <span class="keyword">if</span> (sprite.x &lt;= <span class="number">0</span>) sprite.x = <span class="number">0</span>;
        timeControl = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//触发结束重置时间</span>
    }
}, <span class="literal">true</span>);
</code></pre><p>4.react的路由跳转问题，直接引用this.context.router.push(path)出错。<br><strong>改进：</strong> 在react组件中需加入contextType对象。</p>
<pre><code>ComponentName.contextTypes = {
    router: React.propTypes.<span class="keyword">object</span>.isRequired
} <span class="comment">//组件外加入的所以加上组件名字</span>
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-简谈ES6学习心得" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/13/简谈ES6学习心得/" class="article-date">
  	<time datetime="2017-03-13T12:08:29.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/简谈ES6学习心得/">简谈ES6学习心得</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="let和const">let和const</h3><ul>
<li>let和const具有块级作用域，只在当前块级作用域能访问到</li>
<li>let和const都没有变量声明提升，会有暂时性死区，不可重复声明。<br> <code>test = &#39;abc&#39;;
 let test;   //报错</code></li>
<li>const声明的是常量，在声明之后无法修改它的值，但是声明对象可以修改其属性。<br> <code>const obj = {};
 obj.a = 1;</code></li>
<li>典型用例：for循环<br><code>for(let i=0; i&lt;10; i++) {
 //...
}
console.log(i) //报错</code></li>
</ul>
<h3 id="变量结构赋值">变量结构赋值</h3><p>1.解构不成功，变量值则为undefined<br>2.解构允许有默认值（解构右边值不严格等于undefined，默认值不生效）：</p>
<pre><code><span class="built_in">let</span> [<span class="built_in">test</span> = <span class="number">1</span>] = [undefined]; //<span class="built_in">test</span>为<span class="number">1</span>
<span class="built_in">let</span> [<span class="built_in">test</span> = <span class="number">1</span>] = [null];  //<span class="built_in">test</span>为null
</code></pre><p>3.函数参数的解构赋值+默认值有助于阅读代码和增加代码可维护性：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">({x = 0, y=0} = {})</span> </span>{
    <span class="keyword">return</span> [x, y];
}
<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">({x, y} = {x:0, y:0})</span> </span>{
    <span class="keyword">return</span> [x, y];
}
第一种写法是给参数赋默认值，等号右边传入参数再进行解构赋值；
第二种写法是在没传参数情况下，整个参数对象有默认值，否则等号右边引用传入对象进行解构赋值。
</code></pre><h3 id="Promise对象">Promise对象</h3><p>Promise异步编程解决回调地狱~<br>Promise特点：<br>1.状态不受影响，有pending，resolved，rejected三种状态，并且状态一旦改变就不会再变化，在变化以后再给Promise增加回调函数也能获取到一样的结果。<br>2.Promise对象无法取消，在创建时就立即执行，而且Promise内部错误不会反应到外部，除非设定回调函数，另外，Promise在Pending时无法得知是刚开始还是即将结束。</p>
<p>用法：</p>
<pre><code><span class="keyword">var</span> promise <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>{
    <span class="keyword">if</span>(...) {
        resolve(value);
    }<span class="keyword">else</span> {
        reject(error);
    }
});
promise.then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>{
    <span class="comment">//resolve</span>
}, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{
    <span class="comment">//reject</span>
}).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{
    <span class="comment">//处理前面发生的错误</span>
}).done() <span class="comment">//确保抛出错误，因为catch出错它不会自己抓取自己的错误，可提供onFulfilled和Rejected回调函数</span>
.<span class="keyword">finally</span>() <span class="comment">//无论如何都会执行的操作</span>
</code></pre><h2 id="箭头函数-this">箭头函数-this</h2><p>ES6里边比较大头的一个家伙~<br>首先箭头函数可以简便函数的写法，</p>
<pre><code>function test(arg) {
    ...
}
可写成 test = arg =&gt; <span class="decorator">{...}</span>
function test(x, y) {
    ...
}
可写成 test = (x, y) =&gt; <span class="decorator">{...}</span>
</code></pre><p>但是箭头函数里边比较不同的一点是this的指向：<br><strong>箭头函数的this是在定义的时候确定的，而不是在运行时灵活变动的，而箭头函数本身是没有this的，它的this也就是定义时它的上一层函数（或全局变量）的this。</strong><br><strong>例如：</strong></p>
<pre><code><span class="keyword">var</span> a = <span class="string">'window'</span>;
<span class="keyword">let</span> obj = {
    a : <span class="string">'abc'</span>,
    test : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);
    }
}
obj.test() <span class="comment">//'abc'</span>

<span class="keyword">let</span> obj1 = {
    a : <span class="string">'abc'</span>,
    test : () =&gt; {
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);
    }
}
obj1.test() <span class="comment">//'window'</span>
</code></pre><p>##ES6模块与CommonJS模块</p>
<ol>
<li>ES6模块通过import引入，通过export(或exports.name)将模块接口暴露出去，当然也有合并写法，直接exports<br>… from … (引入并暴露出去)。CommonJS通过require引入模块，通过module.exports暴露接口。</li>
<li>ES6是预编译的，而CommonJS是在运行时确定值的，只是一个值的拷贝，所以使用require(…).name是不保险的，当执行到这句的时候，name不一定存在，就会报错，而ES6则只是一种引用，只要引用存在就不会报错。</li>
<li>CommanJS模块在加载完后会生成一个对象：<br>{<br>id: ‘name’,<br>exports: {…},<br>loaded: true,<br>…<br>｝<br>当多次执行require命令时，也不会多次执行同一个模块，只从模块的exports中取值，除非手动清除系统缓存。</li>
<li>CommanJS在遇到循环加载时，只会输出已经执行的部分，还未执行部分则不输出，a引用b，b又引用a，则在执行b的过程中，会只获得a的部分引用，执行完b再将执行权交还给a执行，也就会出现<strong>第2点</strong>中不安全现象。</li>
<li>ES6在遇到循环加载时，由于ES6的import不是获取到值，而是一种引用，所以当a引用b，b又引用a时，a执行中遇到引用b，执行b，b引用a发现a已经执行，继续执行b，直至执行完b再将执行权限交给a（此过程如果b引用a中还没执行完的变量，则为undefined）。</li>
<li>引用阮一峰大神的ES6电子书中的一个例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  bar();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行完毕'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ES6在这段代码中能正常执行，而CommonJS会报错，因为b在执行时，foo为null，foo()即会报错。</p>
<ol>
<li>当然，两者还是可以兼容互用的，当一个模块使用ES6的方式暴露出来，比如export default name，在CommonJS中可以使用require(…).default属性获取到暴露的接口。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-js高程学习心得（二）--原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/12/js高程学习心得（二）--原型与原型链/" class="article-date">
  	<time datetime="2017-01-11T16:00:00.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/js高程学习心得（二）--原型与原型链/">js高程学习心得（二）--原型与原型链</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="new操作符">new操作符</h2><pre><code><span class="variable"><span class="keyword">var</span> person</span> = new Person();
function New(<span class="function"><span class="keyword">fun</span>) {</span>
    <span class="variable"><span class="keyword">var</span> obj</span> = {'_proto_' : <span class="function"><span class="keyword">fun</span>.prototype}; <span class="comment">//实例原型指向</span></span>
    <span class="keyword">return</span> function() {
        <span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(obj, auguments)</span>;  <span class="comment">//修改this指向</span></span>
        <span class="keyword">return</span> obj;
    }
}
</code></pre><p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/scope.png" alt="原型与原型链"><br>原型C的实例B作为原型B，原型B的实例A作为原型A</p>
<p><strong>工厂模式</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>{
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
    };
    <span class="keyword">return</span> o;
}
<span class="keyword">var</span> person = createPerson(<span class="string">"jacy"</span>, <span class="number">20</span>, <span class="string">"engineer"</span>);
</code></pre><p><strong>构造函数模式</strong></p>
<pre><code>function <span class="keyword">Person</span>(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    };
}
var <span class="keyword">person</span> = new <span class="keyword">Person</span>(<span class="string">"jacy"</span>, 20, <span class="string">"engineer"</span>);
</code></pre><p><strong>原型模式</strong></p>
<pre><code>function <span class="keyword">Person</span>() {};
<span class="keyword">Person</span>.prototype = {
    constructor : <span class="keyword">Person</span>,
    name : <span class="string">"jacy"</span>,
    age : 10,
    job : <span class="string">"engineer"</span>
}; //重写原型对象，constructor重新指向<span class="keyword">Person</span>，但是会变成可枚举属性
var friend = new <span class="keyword">Person</span>(); //与重写原型对象不可调换，由于实例已经指向原来的原型对象，重写原型对象不会改变实例对原来原型对象的指向
</code></pre><p>单一的原型模式对于引用类型数据会出问题：</p>
<pre><code>function <span class="keyword">Person</span>() {};
<span class="keyword">Person</span>.prototype = {
    constructor : <span class="keyword">Person</span>,
    friends : <span class="comment">[1,2,3]</span>
}; 
var person1 = new <span class="keyword">Person</span>();
var person2 = new <span class="keyword">Person</span>();
person1.friends.push(<span class="string">"4"</span>);
console.log(person2.friends); //<span class="string">"1,2,3,4"</span>
</code></pre><p><strong>组合使用构造函数和原型模式</strong></p>
<pre><code>function <span class="keyword">Person</span>(name, age, job) {
    this.friends = <span class="comment">[1,2,3]</span>;
}
<span class="keyword">Person</span>.prototype = {
    constructor : <span class="keyword">Person</span>
}
var person1 = new <span class="keyword">Person</span>(<span class="string">"jacy"</span>, 20, <span class="string">"engineer"</span>);
var person2 = new <span class="keyword">Person</span>(<span class="string">"Jacy"</span>, 20, <span class="string">"engineer"</span>);
person1.friends.push(<span class="string">"4"</span>);
console.log(person2.friends); //<span class="string">"1,2,3"</span>
</code></pre><p><strong>寄生构造函数</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>{
    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();
    values.push.apply(values, <span class="built_in">arguments</span>);
    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);
    }; <span class="comment">//扩展Array构造函数又不直接修改Array构造函数</span>
    <span class="keyword">return</span> values;
}
<span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);
alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span>
</code></pre><p>此方法返回的对象与构造函数和构造函数原型属性间没关系</p>
<p>解决原型链中引用类型值带来的问题：<br><strong>借用构造函数</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];
}
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span> </span>{
    SuperType.call(<span class="keyword">this</span>);
}
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();
instance1.colors.push(<span class="string">"black"</span>);
alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span>
<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();
alert(instance2.colors); <span class="comment">//"red,blue,green"</span>
</code></pre><p><strong>组合式继承–原型链和借用构造函数组合</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>{
    ...
}
SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    ...
}
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>{
    SuperType.call(<span class="keyword">this</span>,name); <span class="comment">//第二次调用</span>
}

SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用</span>
SubType.prototype.constructor = Subtype;
SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    ...
}
</code></pre><p><strong>原型式继承</strong></p>
<pre><code>function <span class="keyword">object</span>(obj) {
    function <span class="function"><span class="title">fun</span><span class="params">()</span> {};</span>
    <span class="function"><span class="keyword">fun</span>.prototype = obj;</span>
    <span class="keyword">return</span> new <span class="function"><span class="title">fun</span><span class="params">()</span>;</span>
}
</code></pre><p>ES5新增Object.create()与object()行为相同<br>只有一个参数时与object相同，第二个参数表示为新对象定义的额外属性对象</p>
<p><strong>寄生式继承</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span> </span>{
    <span class="keyword">var</span> <span class="keyword">clone</span> = object(original); <span class="comment">//object函数非必需</span>
    <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        ...
    }; <span class="comment">//扩展对象</span>
    <span class="keyword">return</span> <span class="keyword">clone</span>;
}
</code></pre><p><strong>寄生组合式继承</strong><br>组合继承两次调用SuperType产生多余属性</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span> {</span>
    var prototype = object<span class="params">(superType.prototype)</span>; <span class="comment">//不采用传统的new操作符直接用原构造函数生成，而用暂时的构造函数生成来实现继承</span>
    prototype.constructor = subType;
    subType.prototype = prototype;
}
<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> {</span>
    ...
}
SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
}
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> {</span>
    SuperType.call<span class="params">(this,name)</span>; 
}
inheritPrototype<span class="params">(SubType, SuperType)</span>;
SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-js高程学习心得（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/05/js高程学习心得（一）/" class="article-date">
  	<time datetime="2017-01-04T16:00:00.000Z" itemprop="datePublished">2017-01-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/js高程学习心得（一）/">js高程学习心得（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“use strict” //使用严格模式</p>
<p>null //空对象指针</p>
<p>typeof操作符检测基本类型（Null,Undefined,Boolean,String,Number）</p>
<p>instanceof检测引用类型(Object,Array,Date,RegExp,Function)和基本包装类型（类似引用类型，不过是瞬间的，String,Number,Boolean）</p>
<p>typeof 未定义变量 = undefined</p>
<p>typeof null = object</p>
<p>NaN == NaN //false</p>
<p>parseInt()第二个参数带进制</p>
<p>parseFloat()只识别十进制</p>
<p>Number() //null返回0，undefined返回NaN</p>
<p>解析对象都是先调用对象的valueOf()，若为NaN则继续调用toString()</p>
<p>标识符开头：字母，_，或者$</p>
<p>toString()可带参数，表示进制</p>
<pre><code><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;
<span class="built_in">num</span>.toString(<span class="number">2</span>)  <span class="comment">//"1010"</span>
</code></pre><p>null和undefined没有toString方法</p>
<p>Infinity * 0 = NaN<br>Infinity / Infinity = NaN<br>0 / 0 = NaN<br>~ / 0 = Infinity或-Infinity</p>
<p>label语句可使break,continue返回到指定位置<br>如：</p>
<pre><code>start: <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {
        <span class="keyword">break</span> start;  <span class="comment">//将会结束两个循环</span>
    }
}
</code></pre><p>with(环境) //不推荐，性能不好</p>
<p>switch(a &lt; b) //这里的比较使用全等比较,不转换类型</p>
<p>arguments对象类型数组，可用[]访问，但不是Array实例，它还有一个属性callee指向arguments所属函数的函数名</p>
<p><strong>ECMAScript无函数签名，其参数是以一个包含0或多个值的数组形式传递（不能重载但类似）</strong></p>
<p><strong>对象按值传递：</strong></p>
<pre><code>var <span class="keyword">person</span> = new Object();
function a(obj) {
    obj.name = <span class="string">"abc"</span>;
    obj = new Object();
    obj.name = <span class="string">"def"</span>;
}
a(<span class="keyword">person</span>);
alert(<span class="keyword">person</span>.name) //<span class="string">"abc"</span>
//按值传递，但按引用来引用同一对象
</code></pre><p><strong>每个执行环境都有一个与之关联的变量对象（环境中变量+函数）<br>变量对象形成作用域链，作用域链前端是当前环境变量对象<br>若环境是函数，则把其活动对象作为变量对象，函数活动对象最初只含有arguments对象</strong></p>
<h2 id="数组方法">数组方法</h2><p>pop() //数组尾部移除一项，返回移除项<br>push() //数组尾部增加项，返回数组长度<br>shift() //数组头部移除一项，返回移除项<br>unshift() //数组头部增加项，返回数组长度<br>slice() //两参数表示起始和结束索引，返回这段索引表示的数组，不影响原数组<br>splice() //可删除可插入，2参数删除，3参数以上插入</p>
<p>indexOf(“项”，起点) //查找项在数组中的索引，默认从0向后查<br>lastIndexOf与indexOf相反，默认从后向前查<br>若没找到则返回-1</p>
<h2 id="数据，字符处理">数据，字符处理</h2><p>toFixed() //字符串形式返回指定个数小数<br>toExponential() //字符串形式返回指定个数小数指数表示法<br>toPrecision()  //返回小数格式或指数格式（根据传入数字，参数表示所有数字位数，不包括指数部分）<br>charAt() //返回指定位置字符<br>charCodeAt() //返回指定位置字符字符编码</p>
<p>slice(起，末) //参数负时加长度<br>substring(起，末) //参数负时取0<br>substr(起，个数) //负时起始位置加长度，个数取0<br>以上三函数是取出指定位置字符串</p>
<p>trim() //去前置后缀空格<br>toUpperCase() //大写 toLocaleUpperCase() 针对地区<br>toLowerCase() //小写 toLocaleLowerCase()</p>
<p>split() //将字符串用指定分隔符分割，存入数组</p>
<p>encodeURI()<br>decodeURI() //解析<br>encodeURIComponent()<br>decodeURIComponent() //解析</p>
<pre><code>var uri=<span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;
encodeURI(uri) //<span class="string">"http://www.wrox.com/illegal<span class="variable">%20value</span>.htm#start"</span>
encodeURIComponent(uri) //<span class="string">"http<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2Fwww</span>.wrox.com<span class="variable">%2Fillegal</span><span class="variable">%20value</span>.htm<span class="variable">%23start</span>"</span>
</code></pre><h2 id="属性描述符">属性描述符</h2><p>数据属性：<br>[[Enumerable]],<br>[[Writable]],<br>[[Value]],<br>[[Configurable]] //改为false就不能改true<br>Object.defineProperty()<br>Object.defineProperties() //定义多个属性</p>
<pre><code>var <span class="keyword">person</span> = {};
Object.defineProperty(<span class="keyword">person</span>,<span class="string">"name"</span>,{
    writable : false,
    value : <span class="string">"Jacy"</span>
})
alert(<span class="keyword">person</span>.name) //<span class="string">"Jacy"</span>
<span class="keyword">person</span>.name = <span class="string">"jacy"</span>;
alert(<span class="keyword">person</span>.name) //<span class="string">"Jacy"</span>
</code></pre><p>访问器属性：<br>[[Enumerable]],<br>[[Configurable]],<br>[[Get]]<br>[[Set]]<br>Object.getOwnPropertyDescriptor(object,”name”)</p>
<pre><code>Object.getOwnPropertyDescriptor(<span class="keyword">person</span>,<span class="string">"name"</span>)
//Object {value: <span class="string">"Jacy"</span>, writable: false, enumerable: false, configurable: false}
</code></pre><p>Object.getPrototypeOf() //获取对象的原型</p>
<pre><code>Object.getPrototypeOf(<span class="keyword">person</span>)
//Object {}
</code></pre><p>Object.keys() //返回对象实例可枚举属性（数组）<br>Object.getOwnPropertyNames() //返回对象实例所有属性（数组）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-project总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/02/project总结/" class="article-date">
  	<time datetime="2016-11-01T16:10:00.336Z" itemprop="datePublished">2016-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/project总结/">project总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没有写博文了，这确实不是个好习惯，毕竟心得体会不会一直牢记心中。</p>
<p>好了，如题，介绍下我的小项目了～</p>
<p><strong>项目名称</strong>：A公司微信公众号上的官方</p>
<p><strong>项目描述</strong>：用轻量级js=&gt;vuejs，通过gulp-webpack打包，部分内容切分出来另外用基本的html，css和js完成，为了使打包后的文件能较小，更加提高打开的性能，虽然路由使用了懒加载（做这个项目时vue-router的文档的懒加载会报错，具体解决办法见下文）。这个项目作为公司官网主要是展示公司的一些信息，比如公司介绍，公司的资讯，公司相关产品等</p>
<p><strong>项目职责</strong>：前端开发，包括页面的实现还有跟后台的接口对接调试</p>
<p><strong>项目技术记录</strong>：</p>
<p><strong>1.</strong>项目目录还是老样子，可复用组件抽出，普通组件分文件夹放好，项目结构就清晰多了，虽然都会这么想，但是做可能会忘了，这也是一种经验。</p>
<p><strong>2.</strong>vue-router的懒加载，查询了相关资料后使用了这种方法有效：</p>
<pre><code>"<span class="tag">pashName</span>": <span class="rules">{         
    <span class="rule"><span class="attribute">component</span>:<span class="value"> <span class="function">function</span>(resolve) {
        require.<span class="function">ensure</span>([<span class="string">'componentPath'</span>], <span class="function">function</span>(){
            <span class="function">resolve</span>(<span class="function">require</span>(<span class="string">'componentPath'</span>))</span></span>;             }</span>);           },
},
</code></pre><p><strong>3.</strong>关于有些页面可能内容无法铺满整个屏幕，而当内容多的时候又能铺满屏幕，这时候可能会困扰背景问题，当内容足够的时候背景就有，而当内容不够的时候呢？<br>    解决：可以设置所需元素的最小高度，让它适应你所需要的高度，这样当内容不够的时候可以正常显示，内容足够的时候也会撑开。</p>
<p><strong>4.</strong>只修改页面参数（params）的路由跳转会有什么事发生呢？比如在某个信息页，它有它的id，而这个信息页可以查看其他相关信息，当点击其他的信息，想跳转并查看其他信息。<br>    答：很遗憾，并没有什么变化，当用router.go()或v-link改变了传入了的params时它只是改变了url，因为目前组件就是渲染的，并没有重新渲染一遍组件。<br>    解决：这时候就需要自己加入refresh事件，可能有很多朋友会想到用window.location.reloas()重新加载，当然这样也可以，但是这样会刷新页面，体验就没那么好了。我们可以将传入的params重新请求所需的信息然后更改data更新信息，这样可以不用刷新便可以将信息更新，当然这还需要加上$(window).scrollTop(0)让页面重新回到顶部。</p>
<p><strong>5.</strong>嗯这是个大坑，把项目拖的非常的慢，打开也是极其的慢，那就是图片的问题，由于这个官网有较多的图片，当时全用的本地链接，导致项目打包出来的文件极其大，当访问的时候就请求js文件要10m左右，这在高网速的时候也要好几秒，甚至好几分钟的相应时间，这是极其不友好的，也非常影响调试效率。后来将文件通过放在‘牛牛’上用外链形式访问，网页加载速度就可以秒开了，这个问题当时也找了好久，最后解决的时候别提有多舒服了～～～谨记！！！</p>
<p><strong>6.</strong>frozen的slider在页面上由于是要将背景设好的，在其他地方可能也可以，但是在vue上想要设置动态的背景图会报错，原因暂时还没有找出来（尴尬），解决当然就只能在js添加相应的li了：</p>
<pre><code>for<span class="list">(<span class="keyword">var</span> i = <span class="number">0</span><span class="comment">; i &lt; res.banner.length; i++) {</span>
  $<span class="list">(<span class="quoted">'#slider1</span> ul')</span>.append<span class="list">(<span class="string">"&lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;"</span>)</span><span class="comment">;</span>
  var backgroundImage = res.banner[i].image_url<span class="comment">;</span>
  $<span class="list">(<span class="quoted">'#slider1</span> ul li')</span>.eq<span class="list">(<span class="keyword">i</span>)</span>.children<span class="list">()</span>.css<span class="list">(<span class="quoted">'backgroundImage</span>',<span class="quoted">'url</span><span class="list">(<span class="quoted">'+backgroundImage+</span>')</span>')</span><span class="comment">;</span>
}</span>
</code></pre><p><strong>7.</strong>接下来是重头戏啦，我们常用的page组件，虽然当时找了很多，但是由于各种原因，找不到比较合适的，后来有了一个page，此处只写引用方法了：</p>
<pre><code>页面中的引用方式，传入改变页面的函数，总页数，记录页数到session，当返回的时候记录当前页面。
<span class="tag">&lt;<span class="title">page</span> <span class="attribute">:total</span>=<span class="value">"total"</span> <span class="attribute">:change-page</span>=<span class="value">"changePage"</span> <span class="attribute">:applistpage</span>=<span class="value">"applistpage"</span>&gt;</span><span class="tag">&lt;/<span class="title">page</span>&gt;</span>

applistpage: sessionStorage.applistpage,

changePage(page) {
    var that = this;
    $.ajax({
      type: 'get',
      url: that.Host+'/Application/appList/group_id/'+that.$route.params.group_id+'/limit/6/start/'+(page-1)*6,
      // async: false,
      dataType: 'json',
      success: function(res) {
        console.log(res);
        that.lists = res.list;
      },
      error: function(err) {
        console.log(err);
      }
    })
    sessionStorage.applistpage = page;
},

            //page.vue
<span class="tag">&lt;<span class="title">template</span>&gt;</span>
  <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"pagination"</span> <span class="attribute">v-show</span>=<span class="value">"showPagination"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> @<span class="attribute">click</span>=<span class="value">"change(1)"</span> <span class="attribute">v-if</span>=<span class="value">"showPre"</span>&gt;</span> <span class="comment">&lt;!-- &amp;lt;&amp;lt; --&gt;</span> 首页<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>  <span class="attribute">v-if</span>=<span class="value">"showPre"</span> @<span class="attribute">click</span>=<span class="value">"prev"</span>&gt;</span><span class="comment">&lt;!-- &amp;lt; --&gt;</span>上一页<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">v-for</span>=<span class="value">"i in showCount"</span>   @<span class="attribute">click</span>=<span class="value">"change(i)"</span>
      <span class="attribute">v-bind:class</span>=<span class="value">"[currentPage ===   i ? 'active' : '']"</span>
      &gt;</span><span class="tag">&lt;<span class="title">a</span>&gt;</span><span class="comment"></span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">v-if</span>=<span class="value">"showTail"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">v-bind:class</span>=<span class="value">"[currentPage === this.lastPage ? 'active' : '']"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">a</span> @<span class="attribute">click</span>=<span class="value">"change(this.lastPage)"</span>&gt;</span><span class="comment"></span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">v-if</span>=<span class="value">"showNext"</span> @<span class="attribute">click</span>=<span class="value">"next"</span>&gt;</span><span class="comment">&lt;!-- &amp;gt; --&gt;</span>下一页<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">v-if</span>=<span class="value">"showNext"</span> @<span class="attribute">click</span>=<span class="value">"change(lastPage)"</span>&gt;</span><span class="comment">&lt;!-- &amp;gt;&amp;gt; --&gt;</span>最后一页<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
  <span class="built_in">module</span>.exports =  {
    components: {

    },
    props: {
      total: {
        type: <span class="built_in">Number</span>,
        <span class="built_in">require</span>: <span class="literal">true</span>
      },
      totalCount:{
        type: <span class="built_in">Number</span>,
        <span class="keyword">default</span>:<span class="number">0</span>
      },
      pageSize: {
        type: <span class="built_in">Number</span>,
        <span class="keyword">default</span>: <span class="number">6</span>
      },
      showCount: {
        type: <span class="built_in">Array</span>,
        <span class="keyword">default</span>() {
          <span class="keyword">return</span> [];
        }
      },
      changePage: {
        type: <span class="built_in">Function</span>,
        <span class="keyword">default</span> () {
          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{};
        }
      },
      apppage: {

      },
      applistpage: {

      },
      machinepage: {

      },
    },
    ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
      <span class="keyword">this</span>.currentPage = <span class="number">1</span>;
      <span class="keyword">this</span>.lastPage = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.total / <span class="keyword">this</span>.pageSize);
      <span class="keyword">var</span> that = <span class="keyword">this</span>;
      <span class="keyword">if</span>(that.apppage) {
        <span class="comment">// setTimeout(function(){</span>
          that.change(that.apppage);
        <span class="comment">// },100)</span>
      }
      <span class="keyword">if</span>(that.applistpage) {
        <span class="comment">// setTimeout(function(){</span>
          that.change(that.applistpage);
        <span class="comment">// },100)</span>
      }
      <span class="keyword">if</span>(that.machinepage) {
        <span class="comment">// setTimeout(function(){</span>
          that.change(that.machinepage);
        <span class="comment">// },100)</span>
      }

    },
    data:  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
      <span class="keyword">return</span> {
        <span class="comment">//当前页数</span>
        currentPage: <span class="number">1</span>,
        <span class="comment">// 最后一页</span>
        lastPage: <span class="number">1</span>,
        showNext:<span class="literal">true</span>,
        showPre:<span class="literal">false</span>,
        showTail:<span class="literal">false</span>,
        showPagination:<span class="literal">true</span>,
      }
    },
    computed: {
      showPagination:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.lastPage == <span class="number">0</span>?<span class="literal">false</span>:<span class="literal">true</span>;
      },
      showPre:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">if</span>(<span class="keyword">this</span>.currentPage == <span class="number">1</span>){
          <span class="keyword">return</span> <span class="literal">false</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      },
      showNext:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">if</span>(<span class="keyword">this</span>.lastPage == <span class="number">1</span>){
          <span class="keyword">return</span> <span class="literal">false</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">if</span>(<span class="keyword">this</span>.lastPage == <span class="keyword">this</span>.currentPage){
            <span class="keyword">return</span> <span class="literal">false</span>;
          }
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      },
      showCount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
                <span class="keyword">var</span> $<span class="keyword">this</span> = <span class="keyword">this</span>;
                <span class="keyword">var</span> ar = [];
                $<span class="keyword">this</span>.currentPage = <span class="built_in">parseInt</span>($<span class="keyword">this</span>.currentPage);
                <span class="keyword">if</span> ($<span class="keyword">this</span>.currentPage &gt; <span class="number">3</span>)
                {
                    ar.push($<span class="keyword">this</span>.currentPage - <span class="number">3</span>);
                    ar.push($<span class="keyword">this</span>.currentPage - <span class="number">2</span>);
                    ar.push($<span class="keyword">this</span>.currentPage - <span class="number">1</span>);
                }<span class="keyword">else</span>
                {
                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; $<span class="keyword">this</span>.currentPage; i++)
                    {
                        ar.push(i);
                    }
                }
                <span class="keyword">if</span> ($<span class="keyword">this</span>.currentPage !== $<span class="keyword">this</span>.lastPage)
                {
                    ar.push($<span class="keyword">this</span>.currentPage);
                }
                <span class="keyword">if</span> ( $<span class="keyword">this</span>.currentPage &lt; ( $<span class="keyword">this</span>.lastPage - <span class="number">3</span> ) )
                {
                    ar.push($<span class="keyword">this</span>.currentPage + <span class="number">1</span>);
                    ar.push($<span class="keyword">this</span>.currentPage + <span class="number">2</span>);
                    ar.push($<span class="keyword">this</span>.currentPage + <span class="number">3</span>);
                    <span class="keyword">if</span> ( $<span class="keyword">this</span>.currentPage &lt; ( $<span class="keyword">this</span>.lastPage - <span class="number">4</span> ) )
                    {
                        $<span class="keyword">this</span>.$set(<span class="string">"showTail"</span>, <span class="literal">true</span>);
                    }
                }<span class="keyword">else</span>
                {
                    $<span class="keyword">this</span>.$set(<span class="string">"showTail"</span>, <span class="literal">false</span>);
                    <span class="keyword">for</span> (<span class="keyword">var</span> i = ($<span class="keyword">this</span>.currentPage + <span class="number">1</span>); i &lt; $<span class="keyword">this</span>.lastPage; i++)
                    {
                        ar.push(i);
                    }
                }
                <span class="keyword">return</span> ar;
            },
    },
    watch: {
      total (val, oldval) {
        <span class="keyword">this</span>.lastPage = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.total / <span class="keyword">this</span>.pageSize);
        <span class="comment">// this.currentPage = 1;</span>
      },
      totalCount(v){
        <span class="keyword">if</span>(v == <span class="number">0</span>){
          <span class="keyword">this</span>.currentPage = <span class="number">1</span>;
        }
      }
    },
    methods: {
      prev () {
        <span class="keyword">if</span>(<span class="keyword">this</span>.currentPage == <span class="number">1</span>){
          <span class="keyword">this</span>.showPre = <span class="literal">false</span>;
          <span class="keyword">return</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">this</span>.showPre = <span class="literal">true</span>;
        }
        <span class="keyword">this</span>.currentPage = --<span class="keyword">this</span>.currentPage;
        <span class="keyword">this</span>.change(<span class="keyword">this</span>.currentPage);

      },
      next () {
        <span class="keyword">if</span>(<span class="keyword">this</span>.currentPage == <span class="keyword">this</span>.lastPage){
          <span class="keyword">this</span>.showNext = <span class="literal">false</span>;
          <span class="keyword">return</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">this</span>.showNext = <span class="literal">true</span>;
        }
        <span class="keyword">this</span>.currentPage = ++<span class="keyword">this</span>.currentPage;
        <span class="keyword">this</span>.change(<span class="keyword">this</span>.currentPage);

      },
      change (page) {
        <span class="keyword">if</span> (page === <span class="number">1</span>) {
          <span class="keyword">this</span>.showPre = <span class="literal">false</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">this</span>.showPre = <span class="literal">true</span>;
        }
        <span class="keyword">if</span> (page === <span class="keyword">this</span>.lastPage) {
          <span class="keyword">this</span>.showNext = <span class="literal">false</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">this</span>.showNext = <span class="literal">true</span>;
        }
        <span class="keyword">if</span>(page&lt; <span class="keyword">this</span>.lastPage-<span class="number">4</span>){
          <span class="keyword">this</span>.showTail = <span class="literal">true</span>;
        }<span class="keyword">else</span>{
          <span class="keyword">this</span>.showTail = <span class="literal">false</span>;
        }
        <span class="keyword">this</span>.currentPage = page;
        <span class="keyword">this</span>.changePage(page);
      }
    }
  }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><strong>8.</strong>活动页主要处理的就是表情的问题了，emoji表情啊，想必大家在发微信墙的时候都想要用表情表达下自己当时的心情吧，但是文字完全不能展现啊～<br>    好的我们上emoji的了：<a href="https://github.com/OneSignal/emoji-picker.git" target="_blank" rel="external">https://github.com/OneSignal/emoji-picker.git</a><br>    当然github中有很多这些可以引用看看，但是试了那么多还是这个比较符合要求，看着代码我还改了那么一丢丢，它原先是禁用了iphone的，我重新把它开上了，但是这个主要是用插件自带的emoji表情，而不是我们的输入法带的，这就非常的不舒服了。经过test，它在iPhone上使用输入法的emoji表情还是支持的，但是在安卓上就不行了，真是，伟大的程序员又要出来解决这些麻烦事了，嘿嘿嘿，虽然到现在还没解决，稍微有点眉目吧，等我再细研究研究这些编码问题先～～<br>    当然了，如果浏览器或者输入法能像iphone那样支持的话多好啊，方便开发者，方便用户，当然，问题还是要解决的！</p>
<p>好了，这次的博文就到这里了，这里还发现我写的代码注释可能还不是特别的够，虽然语义上够了，但是适当注释还是不要偷懒加上～～又尴尬了～另外md编辑博文其实还是不太方便，要想加多点元素确实还是比较麻烦的，看我这么简洁的写就知道了，可能在稍微有点久的将来我就自己开发一个博文好了，方便自己使用，到时有了再给大家分享把。。！行吧该睡觉了，给各位看博文的说晚安了。。！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-我们家CSCWFE+总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/19/我们家CSCWFE+总结/" class="article-date">
  	<time datetime="2016-08-19T15:49:29.868Z" itemprop="datePublished">2016-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/19/我们家CSCWFE+总结/">我们家CSCWFE+总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CSCWFE">CSCWFE</h2><blockquote>
<p>新招收的一帮小伙子小姑娘还挺不错,怎么说在学习态度上还是挺让人欣慰的,希望这一个月的培训能给他们带来帮助,哈哈未来是你们的!</p>
<p>一个月培训下来,自己在做准备工作的时候还是有一些收获,有些不常用忘掉的知识可以补回来,原有的知识还能加深理解,跟小伙子小姑娘们一起的这段时间是非常快乐的~再详细的东西就记在心中,不多说啦.</p>
</blockquote>
<h2 id="总结">总结</h2><h3 id="中秋佳节">中秋佳节</h3><p><strong>项目FE技术:</strong> 中秋活动采用vuejs框架,使用gulp webpack打包,gulp livereload的自动刷新功能对开发提供了很大的便利,vue以组件切换的形式代替了传统的页面跳转刷新实现视图的切换.<br><strong>项目目的:</strong> 为了更好的卖月饼O(∩_∩)O!!!购买月饼的客户可拥有发起祝福的机会,通过祝福的分享点赞列出排行,从而通过排名送出活动礼品.<br><strong>项目技术内容分析+收获:</strong></p>
<p>1.由于原先有写过vue项目,所以对vue的开发还是有点经验的,对于一些小细节上的问题还是能注意到,但是这次是完全的自己写的项目,出现的问题还是不少,收获很大.</p>
<p>2.样式的问题,由于使用vue是将项目所有的js文件打包成一个js,所有的style打包在一起,所以不同组件的class名需要区分开来,不然虽然style写在不同组件,但由于最后是打包在一块,所以是一起加载的,会影响各个组件的样式.</p>
<p>3.逗号问题,在vue中逗号也是一个需要时刻注意的小细节,在每一个变量,每一个函数,每一个块后边都习惯性的加一个逗号,否则会报错,虽然在终端能看到错误的位置,但是注意好这些细节还是能节约开发时间,时间是宝贵的,虽然看起来似乎不多,但给自己少制造麻烦是个好习惯.</p>
<p>4.routerjs</p>
<pre><code><span class="string">"/receive"</span>: {
    component: receive
},
<span class="string">"/receiveList/:userId"</span>: {
    name: <span class="string">'userList'</span>,
    component: receiveList
},
<span class="string">"/blessingDetail/:wishId/:state"</span>: {
    name: <span class="string">'blessingDetail'</span>,
    component: blessingDetail
},

/receive路由路径名,name此路由(表示整个路由)名字,component此路由加载的组件,组件的切换位置对应相应的router-view标签内,/:wishId表示对路由传入的数据,在路由中接收,router.go()或v-link需带上params对象,另外还有subRoutes表示此路由的子路由,路由可层层递进.
</code></pre><p>5.background,background-size:100% 100%可使背景图在当前区域完全拉伸显示出来,但是这会有点输入框弹出输入法将背景往上挤压的问题,通过background-size:cover可以解决挤压问题,cover是让背景覆盖在区域上,但是cover在图片较大时会使图片显示不全,background-attachment:fixed可使背景固定不动,而默认的scroll表示背景会随着内容的滚动的滚动上去.</p>
<p>6.cookie设置记录登录状态</p>
<pre><code><span class="keyword">var</span> setCookie = <span class="function"><span class="keyword">function</span>(<span class="params">name, value, expires, path, domain, secure</span>)</span>{
    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);
    <span class="keyword">var</span> cookieDate = <span class="keyword">new</span> <span class="built_in">Date</span>();
    cookieDate.setDate(cookieDate.getDate() + expires);
    <span class="comment">// if(expires instanceof Date) {</span>
    <span class="comment">//     cookieText += "; expires=" + expires.toGMTString();</span>
    <span class="comment">// }</span>
    cookieText += <span class="string">"; expires="</span> + cookieDate.toGMTString();
    <span class="keyword">if</span>(path) {
        cookieText += <span class="string">"; path="</span> + path;
    }
    <span class="keyword">if</span>(domain) {
        cookieText += <span class="string">"; domain="</span> + domain;
    }
    <span class="keyword">if</span>(secure){
        cookieText += <span class="string">"; secure"</span>;
    }
    <span class="built_in">document</span>.cookie = cookieText;
};

     setCookie(<span class="string">"phone"</span>, me.telephone, <span class="number">30</span>);

    <span class="keyword">var</span> getCookie = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>{
        <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span>;
        <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);
        <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;
        <span class="keyword">if</span>(cookieStart &gt; -<span class="number">1</span>) {
            <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span> , cookieStart);
            <span class="keyword">if</span>(cookieEnd == -<span class="number">1</span>) {
                cookieEnd = <span class="built_in">document</span>.cookie.length;
            }
            cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));
        }
        <span class="comment">// console.log(cookieValue);</span>
        <span class="comment">// this.telephone = '123';</span>
        <span class="keyword">return</span> cookieValue;
    };

    <span class="keyword">if</span>(getCookie(<span class="string">"phone"</span>) !== <span class="literal">null</span>){
        <span class="keyword">this</span>.$route.router.go({
            name: <span class="string">"userList"</span>,
            params: {
                userId : getCookie(<span class="string">"phone"</span>)
            },
        });
    }
</code></pre><p>7.验证码倒计时:event为触发的函数的参数,触发时无需传入</p>
<pre><code><span class="keyword">var</span> time = <span class="number">60</span>;
<span class="keyword">var</span> timer;
timer = setInterval(function(){
    <span class="keyword">if</span>(time &gt; <span class="number">0</span>){
        <span class="keyword">this</span>.retimer = <span class="keyword">true</span>;
        <span class="keyword">event</span>.target.innerHTML = <span class="string">"还有 "</span> + (time--) + <span class="string">" 秒"</span>;
        <span class="keyword">event</span>.target.disabled = <span class="keyword">true</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">this</span>.retimer = <span class="keyword">false</span>;
        window.clearInterval(timer);
        <span class="keyword">event</span>.target.innerHTML = <span class="string">"获取验证码"</span>;
        <span class="keyword">event</span>.target.disabled = <span class="keyword">false</span>;
    }
}, <span class="number">1000</span>);
</code></pre><p>8.变量的作用域,全局的变量可以存在data中,使用this关键字访问.</p>
<p>9.</p>
<blockquote>
<p>最后也是最大的boss,微信的api,原先以为只是简单的调用api,谁知是个大坑.微信的api还是有很多不完善的地方,签名上头一步错,后面一直没法用,时间就这么拖着,当可以使用了又有很多使用上的困难,在每一个需要使用微信接口的页面都需要对微信接口进行配置.</p>
<p>比如,想要听取微信的接收的录音,由于不是发出端,所以没有发送的本地id可以在微信听取录音中直接调用,这样的话就需要另外写个播放器来听取录音.又由于微信录取的录音是arm格式,h5中audio不支持arm格式,找了很久的转码方式,最后还是后台那边转码传过来才能听取.</p>
<p>另外,需要特别注意的一点是,想要微信接口支持iphone,在加入</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>后还需要另外加入</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>而且,还没有探究出来的一个bug就是在多个页面上,有的写了禁止分享操作,有的写了分享操作,在Android上是可以正常执行的,但是在iPhone上会导致这几个页面全部都没有分享,这是项目正常运行的一个重要的细节,当时这问题是通过绕过问题来跳过了,但是绕过问题而不是解决的问题的方法是不支持的,这个问题还值得探究探究.</p>
<p>总之,微信api坑不少,可能以后还会遇到其他的,慢慢积累经验吧~</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/娱乐-经验/">娱乐+经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-异步编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/25/异步编程/" class="article-date">
  	<time datetime="2016-07-25T06:44:18.321Z" itemprop="datePublished">2016-07-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/25/异步编程/">异步编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>偏函数用法</strong></p>
<pre><code><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;
<span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>{
    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object String]'</span>;
};
<span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>{
    <span class="keyword">return</span> oString.call(obj) == <span class="string">'[object Function]'</span>;
};
</code></pre><p>工厂模式：</p>
<pre><code><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> <span class="params">(type)</span> </span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>{
        <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + type + <span class="string">']'</span>;
    };
};
<span class="keyword">var</span> isString = isType(<span class="string">'String'</span>);
<span class="keyword">var</span> isFunction = isType(<span class="string">'Function'</span>);
</code></pre><p><strong>事件发布/订阅</strong></p>
<pre><code><span class="comment">//订阅</span>
emitter.on(<span class="string">"evebt1"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>{
    <span class="built_in">console</span>.log(message);
});

<span class="comment">//发布</span>
emitter.emit(<span class="string">'event1'</span>,<span class="string">"I am message!"</span>);
</code></pre><p>Node对事件发布/订阅机制做了额外处理：</p>
<p>1.如果对一个时间添加超过10个侦听器会得到一条警告。这跟Node自身单线程有关，设计者认为侦听器太多可能存在内存泄漏。调用emitter.setMaxListeners(0)可以将这个限制去掉。另外，由于事件发布会引起一系列侦听器执行，如果侦听器过多，可能过多占用CPU。<br>2.为处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加侦听器，若有则错误交给侦听器处理，否则抛出异常。如果外部没有捕获这个异常，将会引起线程退出。健壮的EventEmitter实例应对error事件做处理。</p>
<p><strong>继承events模块</strong></p>
<pre><code><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);
<span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>{
    events.EventEmitter.call(<span class="keyword">this</span>);
}
util.inherits(Stream, events.EventEmitter);(Node在util中封装了继承方法)
</code></pre><p><strong>EventProxy模块解决多异步之间的协作</strong></p>
<pre><code><span class="keyword">var</span> proxy = new <span class="type">EventProxy</span>();
proxy.all(<span class="string">"template"</span>, <span class="string">"data"</span>, <span class="string">"resources"</span>, function (<span class="keyword">template</span>, data, resources) {
    //<span class="type">TODO</span>
});
fs.readFile(template_path, <span class="string">"utf8"</span>, function (err, <span class="keyword">template</span>) {
    proxy.emit(<span class="string">"template"</span>, <span class="keyword">template</span>);
});
db.query(sql, function (err, data) {
    proxy.emit(<span class="string">"data"</span>, data);
});
l10n.get(function (err, resources) {
    proxy.emit(<span class="string">"resources"</span>, resources);
});
</code></pre><p>EventProxy提供了一个all()方法来订阅多个事件，当每个事件都被触发后，侦听器才会执行一次。另外一个tail()是侦听器在满足条件时执行一次后，如果组合事件中的某个事件再次触发，侦听器会用最新数据继续执行。</p>
<p><strong>EventProxy的异常处理</strong></p>
<p>EventProxy提供了fail()和done()两个实例方法优化异常处理，使开发关注业务部分，而不是异常捕获上。<br>fail():</p>
<pre><code>ep.fail(<span class="keyword">callback</span>);
等价于：
ep.fail(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
    <span class="keyword">callback</span>(err);
});
等价于：
ep.bind(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
    <span class="comment">//卸载掉所有处理函数</span>
    ep.unbind();
    <span class="comment">//异常处理</span>
    <span class="keyword">callback</span>(err);
});
</code></pre><p>done():<br>ep.done(‘tpl’);<br>等价于：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="params">(err, content)</span> </span>{
    <span class="keyword">if</span> (err) {
        <span class="comment">//一旦发生异常，交给error事件处理函数处理</span>
        <span class="keyword">return</span> ep.emit(<span class="string">'error'</span>, err);
    }
    ep.emit(<span class="string">'tpl'</span>, content);
}
</code></pre><p>done()方法也接受一个函数作参数：</p>
<pre><code>ep.done(<span class="function"><span class="keyword">function</span> <span class="params">(content)</span> </span>{
    <span class="comment">//TODO</span>
    <span class="comment">//这里无需考虑异常</span>
    ep.emit(<span class="string">'tpl'</span>, content);
});
等价于：
<span class="function"><span class="keyword">function</span> <span class="params">(err, content)</span> </span>{
    <span class="keyword">if</span> (err) {
        <span class="comment">//一旦发生异常，交给error事件处理函数处理</span>
        <span class="keyword">return</span> ep.emit(<span class="string">'error'</span>, err);
    }
    (<span class="function"><span class="keyword">function</span> <span class="params">(content)</span> </span>{
        <span class="comment">//TODO</span>
        <span class="comment">//这里无需考虑异常</span>
        ep.emit(<span class="string">'tpl'</span>, content);
    }(content));
}
</code></pre><p><strong>then方法</strong></p>
<p>1.接受完成态、错误态的回调方法。<br>2.可选的支持progress事件回调作为第三个方法。<br>3.then()方法只接受function对象，其余对象被忽略。<br>4.then()方法继续返回Promise对象，实现链式调用。<br>then方法定义：<br>then(fulfilledHandler, errorHandler, progressHandler)</p>
<p><strong>以上为最为主流的模式：事件发布/订阅模式和Promise/Deferred模式</strong></p>
<h3 id="非模式化应用">非模式化应用</h3><p><strong>尾触发和Next</strong><br>尾触发目前应用最多的地方是Connect的中间件<br>最简单的中间件：</p>
<pre><code><span class="function"><span class="keyword">function</span><span class="params">(req请求对象, res响应对象, next尾触发函数)</span></span>{
    <span class="comment">//中间件</span>
}
</code></pre><p>Connect的核心实现：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createServer</span> <span class="params">()</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">app</span><span class="params">(req, res)</span>{</span>app.handle<span class="params">(req, res)</span>;}
    utils.merge<span class="params">(app, proto)</span>;
    utils.merge<span class="params">(app, EventEmitter.prototype)</span>;
    app.route = '/';
    app.stack = [];<span class="comment">//核心，中间件队列</span>
    <span class="keyword">for</span><span class="params">(var i = <span class="number">0</span>;i &lt; arguments.length; i++)</span>{
        app.<span class="keyword">use</span><span class="params">(arguments[i])</span>;
    }
    return app;
};
app.<span class="keyword">use</span> = <span class="function"><span class="keyword">function</span><span class="params">(route, fn)</span>{</span>
    <span class="comment">// some code</span>
    this.stack.push<span class="params">({ route: route, handle: fn})</span>;
    return this;
}
Node原声合同http模块实现监听：
app.listen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    var server = http.createServer<span class="params">(this)</span>;
    return server.listen.apply<span class="params">(server, arguments)</span>;
};
处理每一个监听到的网络请求：
app.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, out)</span>{</span>
    <span class="comment">//some code</span>
    next<span class="params">()</span>;
}
简化后的next<span class="params">()</span>:
<span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span> {</span>
    <span class="comment">//some code</span>
    <span class="comment">//next callback</span>
    layer = stack[index++];
    layer.handle<span class="params">(req, res, next)</span>;<span class="comment">//传入next持续触发</span>
}
</code></pre><p><strong>流程控制模块async</strong><br>异步的串行执行：series()方法</p>
<pre><code>async.series([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span></span>{
        fs.readFile(<span class="string">'file1.txt'</span>,<span class="string">'utf-8'</span>,<span class="keyword">callback</span>);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span></span>{
        fa.readFile(<span class="string">'file2.txt'</span>,<span class="string">'utf-8'</span>,<span class="keyword">callback</span>);
    }
],<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span> </span>{
    <span class="comment">//results =&gt; [file1.txt, file2.txt]</span>
});
等价于：
fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, content)</span></span>{
    <span class="keyword">if</span> (err) {
        <span class="keyword">return</span> <span class="keyword">callback</span>(err);
    }
    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> </span>{
        <span class="keyword">if</span>(err) {
            <span class="keyword">return</span> <span class="keyword">callback</span>(err);
        }
        <span class="keyword">callback</span>(<span class="literal">null</span>, [content, data]);
    });
});
</code></pre><p>异步的并行执行：parallel()方法</p>
<pre><code>async.parallel([
    <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>{
        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">callback</span>);
    },
    <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>{
        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">callback</span>);
    }
], <span class="function"><span class="keyword">function</span> <span class="params">(err, results)</span> </span>{
    <span class="comment">//results =&gt; [file1.txt, file2.txt]</span>
});
等价于：
<span class="keyword">var</span> counter = <span class="number">2</span>;
<span class="keyword">var</span> results = [];
<span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> <span class="params">(index, value)</span></span>{
    results[index] = value;
    counter--;
    <span class="keyword">if</span>(counter === <span class="number">0</span> ) {
        <span class="keyword">callback</span>(<span class="literal">null</span>, results);
    }
};
<span class="comment">//只传递第一个异常</span>
<span class="keyword">var</span> hasErr = <span class="literal">false</span>;
<span class="keyword">var</span> fail = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
    <span class="keyword">if</span>(!hasErr) {
        hasErr = <span class="literal">true</span>;
        <span class="keyword">callback</span>(err);
    }
};
fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, content)</span> </span>{
    <span class="keyword">if</span> (err) {
        <span class="keyword">return</span> fail(err);
    }
    done(<span class="number">0</span>, content);
});
fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, content)</span> </span>{
    <span class="keyword">if</span> (err) {
        <span class="keyword">return</span> fail(err);
    }
    done(<span class="number">1</span>, data);
});
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-异步I-O" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/异步I-O/" class="article-date">
  	<time datetime="2016-07-11T08:36:36.889Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/异步I-O/">异步I/O</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>异步I/O与非阻塞I/O</strong></p>
<p>阻塞I/O：调用之后等到系统内核层面完成所有操作后调用结束，造成CPU等待I/O，浪费等待时间，CPU处理能力不能充分利用。<br>非阻塞I/O：调用之后立即返回，CPU时间片可以用来处理其他事务，提升性能。但其立即返回的不是完整数据，而是调用状态，应用程序需要利用轮询的办法重复调用I/O来获取完整数据和确认是否完成。（让CPU处理状态判断，浪费CPU资源）</p>
<p><strong>轮询技术</strong></p>
<p>read：最原始，性能最低。通过重复调用检查I/O状态完成。在得到最终数据前，CPU一直耗在等待上。<br>select：改进成通过文件描述符上事件状态来判断。有一个较弱限制，通过一个1024长度数组来存储状态，最多可同时检查             1024个文件描述符。<br>poll：改进成通过链表存储，性能限制有所改善，跟select类似。<br>epoll：Linux下效率最高的I/O事件通知机制，在进入轮询时没有检查到I/O事件时进行休眠，直到事件发生唤醒。它真实利用了事件通知、执行回调的方式，而不是遍历查询，不会浪费CPU，执行效率较高。<br>kqueue：该方案实现与epoll类似，不过它仅在FreeBSD系统下存在。</p>
<p>轮询技术满足了非阻塞I/O确保获取完整数据的需求，但对于应用程序仍然算是同步，应用程序仍然需要等待I/O完全返回。</p>
<p><strong>请求对象</strong></p>
<p>从javascript发起调用到内核执行I/O操作的过渡过程中，存在一种中间产物，叫请求对象。<br>javascript调用-&gt;node核心模块-&gt;c++内建模块-&gt;通过libuv进行系统调用<br>libuv作为封装层，有两个平台的实现（win和unix），实际上调用了uv_fs_open()方法，在其调用过程中，创建了FSReqWrap对象，javascript层传入的参数和方法封装在这个请求对象中，回调函数则设置在这个对象的oncomplete_sym属性上。<br>请求对象是异步I/O过程的重要中间产物，所有状态都保存在这个对象，包括送入线程池等待执行及I/O操作完毕后的回调处理。</p>
<p>小结<br>异步I/O：单线程、事件循环、观察者和I/O线程池。在Node中，javascript是单线程，node自身是多线程的，只是I/O线程使用的CPU较少。另一个需要重视的观点是，除了用户代码无法并行执行外，所有I/O（磁盘I/O和网络I/O等）是可以并行起来的。</p>
<p><strong>非I/O的异步API</strong></p>
<p>立即异步执行：<br>setTimeout(function(){<br>    //<br>},0);<br>这种方法较浪费性能<br>process.nextTick(function(){<br>    console.log(‘延迟执行’)；<br>})；<br>console.log(‘正常执行’)；<br>输出：<br>正常执行<br>延迟执行</p>
<p>setImmediate(function(){<br>    console.log(‘延迟执行’)；<br>})；<br>console.log(‘正常执行’)；<br>输出：<br>正常执行<br>延迟执行<br>process.nextTick()跟setImmediate()类似，但：<br>process.nextTick(function(){<br>    console.log(‘nextTick延迟执行’)；<br>})；<br>setImmediate(function(){<br>    console.log(‘setImmediate延迟执行’)；<br>})；<br>console.log(‘正常执行’)；<br>输出：<br>正常执行<br>nextTick延迟执行<br>setImmediate延迟执行<br>process.nextTick()中回调函数优先级高于setImmediate()。因为事件循环对观察者的检查有先后顺序，process.nextTick()属于idle观察者，setImmediate()属于check观察者。<br>每一轮循环检查中，idle观察者&gt;I/O观察者&gt;check观察者</p>
<p>process.nextTick()的回调函数存在一个数组中，每轮循环全部执行完；<br>setImmediate()每轮只执行链表中的一个回调函数。</p>
<p>事件驱动和高性能服务器<br>经典服务器模型：<br>同步式：一次处理一个请求，其余请求处于等待状态；<br>每进程/每请求：每个请求创建一个进程，可处理多个请求，但不具备扩展性，系统资源有限；<br>每线程/每请求：每个请求创建一个线程，可处理多个请求，线程比进程轻量，但每个线程也占内存，对于大型站点仍然不够。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-linux ubuntu安装iNode" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/linux ubuntu安装iNode/" class="article-date">
  	<time datetime="2016-05-27T05:04:57.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/linux ubuntu安装iNode/">linux ubuntu安装iNode</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>本来在宿舍只需要使用舍友“外坏”就可以在ubuntu上安心上网的，可惜最近舍友“外坏”开不流畅，而且校园网也炸炸的，那么就决定在ubuntu上装好iNode自己来开网了，装iNode一天游开始了。
</code></pre><p>在广工网管中心下到了linux版本的iNode包回来解压后，先</p>
<pre><code><span class="keyword">cd</span> iNode解压包目录
./install.<span class="keyword">sh</span>  安装iNode
./iNodeClient 运行iNode
</code></pre><p>接下来就是看它抛出的错误了，我估摸着肯定会少这少那，反正我是。查阅了很多资料，似乎是跟系统64位而这个iNode只是32位应用有关，于是要解决它的库问题。</p>
<pre><code><span class="tag">sudo</span> <span class="tag">apt-get</span> <span class="tag">install</span> <span class="tag">lib32z1</span> <span class="tag">lib32ncurses5</span> <span class="tag">lib32bz2-1</span><span class="class">.0</span> <span class="tag">libjpeg62</span><span class="pseudo">:i386</span> <span class="tag">libpangoxft-1</span><span class="class">.0-0</span><span class="pseudo">:i386</span> <span class="tag">libpangox-1</span><span class="class">.0-0</span><span class="pseudo">:i386</span> <span class="tag">libsm6</span><span class="pseudo">:i386</span> <span class="tag">libidn11</span><span class="pseudo">:i386</span>
</code></pre><p>这里需要注意i386，i386通常被用来作为对Intel（英特尔）32位微处理器的统称。后续缺少的东西也是要注意加这个，不然没用。<br>装好这些后基本上没什么问题了，要是还是有缺什么就找什么补什么吧。下面这个问题就神奇了。</p>
<pre><code>libtiff.so<span class="number">.3</span>: cannot <span class="built_in">open</span> shared object <span class="built_in">file</span>: No such <span class="built_in">file</span> <span class="operator">or</span> <span class="built_in">directory</span>
</code></pre><p>但是自己查找的时候发现还是有这么个文件的，其实并不是因为缺少了这个文件，而是ubuntu中这个库文件升级了，引用不到。</p>
<pre><code><span class="keyword">cd</span> /usr/lib/i386-linux-gnu
<span class="keyword">ls</span> libtiff*
</code></pre><p>输入以上命令查看本机的libtiff的版本是多少的，我的是5的那就拿5作事例。</p>
<pre><code>cd /usr/lib/i386-linux-gnu/ cd到这个目录
sudo rm libtiff<span class="class">.so</span>.<span class="number">3</span> 删除原有的libtiff<span class="class">.so</span>.<span class="number">3</span>
sudo ln -s /usr/lib/i386-linux-gnu/libtiff<span class="class">.so</span>.<span class="number">5</span> /usr/lib/i386-linux-gnu/libtiff<span class="class">.so</span>.<span class="number">3</span> 创建一个libtiff<span class="class">.so</span>.<span class="number">3</span>是链接到libtiff<span class="class">.so</span>.<span class="number">5</span>的
</code></pre><p>然后这块基本就没什么问题了。接下来我们再次</p>
<pre><code>./iNodeClient
</code></pre><p>如果有<code>Gtk-Message: Failed to load module &quot;canberra-gtk-module&quot;</code>出现</p>
<pre><code>sudo apt-get install libcanberra-gtk-<span class="class"><span class="keyword">module</span>:<span class="title">i386</span></span>
</code></pre><p>同样留意i386，如果有类似的出现，查找相关命令下载即可<br>当执行<code>./iNodeClient</code>出现客户端界面就基本上完成安装啦</p>
<p>看到客户端的界面，选择左上角的新建添加链接<br><img src="http://img1.ph.126.net/GZknSWgmRimiJ3kge7FBaA==/647955396405058911.jpg" alt="界面"><br>输入用户名和密码，按照下图点击选项，确定保存<br><img src="http://img3.ph.126.net/ZT9_EE9UGU5fLlqLSkzCvQ==/993325192829036033.jpg" alt="创建连接"><br>新的链接已经建立好了，选中链接，点击上方的“连接”按钮开始连接<br><img src="http://img4.ph.126.net/SAP09r3GcPMaNdDDFMyvMg==/2710041075787328544.jpg" alt="连接"><br>看到“You have passed the identity authentication”的字样时就表示认证成功，就可以上网啦！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Node模块机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/20/Node模块机制/" class="article-date">
  	<time datetime="2016-05-20T09:11:19.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/Node模块机制/">Node模块机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code><span class="keyword">js</span>规范缺陷：
      没有模块系统；
      标准库较少；
      没有标准接口；
      缺乏包管理系统。
</code></pre><p>CommonJS规范提出弥补当前javascript没有标准的缺陷。</p>
<p>CommonJS模块引用：require()</p>
<p>上下文提供了exports对象用于导出当前模块的方法或变量：</p>
<pre><code><span class="comment">//main.js</span>
exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{

}
<span class="comment">//program.js</span>
<span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);
exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>{
    <span class="keyword">return</span> math.add(val,<span class="number">1</span>);
}
</code></pre><p>错误：</p>
<pre><code><span class="keyword">exports</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ...
}</span>;</span>
</code></pre><p>exports对象是通过形参方式传入，直接赋值会改变形参的引用，但不能改变作用域外的值</p>
<pre><code>var change = <span class="function"><span class="keyword">function</span><span class="params">(a)</span> {</span>
    a = <span class="number">100</span>;
    console.<span class="built_in">log</span><span class="params">(a)</span>; <span class="comment">//100</span>
};
var a = <span class="number">10</span>;
change<span class="params">(a)</span>;
console.<span class="built_in">log</span><span class="params">(a)</span>; <span class="comment">//10</span>
</code></pre><p>如果要达到require引入一个类的效果，赋值给module.exports对象，这个迂回的方案不改变形参的作用。</p>
<p>node模块分为node提供的核心模块跟用户编写的文件模块。<br>核心模块在node源代码编译时已编译，node启动时即加入内存，省去文件定位和编译执行步骤，在路径分析中优先判断，故加载速度最快。<br>文件模块运行时动态加载，需完整路径分析、文件定位、编译执行过程，速度比较慢。</p>
<p>不论核心模块还是文件模块，对相同模块二次加载一律缓存优先，这是第一优先级的，不同之处在与核心模块的缓存检查优先于文件模块的。</p>
<p>不可以加载一个与核心模块标识符相同的自定义模块。</p>
<p>模块路径是node在定位文件模块的具体文件时制定的查找策略，其类似于javascript的原型链或者作用域链，先在当前文件目录下的node_modules目录查找，然后沿路径向上逐级递归，这是自定义模块加载速度是最慢的原因。</p>
<p>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况，这时按照.js,.json,.node次序查找。</p>
<p>.js文件：通过fs模块同步读取文件后编译执行；<br>.node文件：是c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件；<br>.json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果；<br>其余扩展名文件：当作js文件载入。</p>
<p>编译过程中，node会对js文件内容进行包装：</p>
<pre><code>(<span class="function"><span class="keyword">function</span>(<span class="params">exports,requiere,module,_filename,_dirname</span>)</span>{
    <span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);
    exports.area = <span class="function"><span class="keyword">function</span>(<span class="params">radius</span>) </span>{
        <span class="keyword">return</span> <span class="built_in">Math</span>.PI*radius*radius;
     };
});
</code></pre><p>这样每个模块文件之间进行作用域隔离，不污染全局变量。</p>
<h2 id="包与npm"><strong>包与npm</strong></h2><p>在一个具体的包目录下执行npm test时，会运行test指向的脚本。<br>npm init 生成package.json文件<br>npm adduser 注册账号，npm必须要使用仓库账号才能将包发布到仓库中<br>npm publish . 上传包<br>npm owner 管理包的所有者（npm owner ls/npm owner add/npm owner rm）<br>npm ls 这个命令可以分析当前路径下可以通过模块路径找到的所有包</p>
<p>包质量和安全问题：<br>口碑效应，在npm模块首页依赖榜可以说明模块的质量和可靠性；<br>GitHub中模块项目的观察者数量和分支数量也能侧面反应其可靠性和流行度；<br>包的测试用例，没有单元测试和文档的包基本上是无法被信任的。</p>
<p>AMD规范：</p>
<pre><code>define([<span class="string">'dep1'</span>,<span class="string">'dep2'</span>],<span class="function"><span class="keyword">function</span><span class="params">(dep1,dep2)</span></span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};
});
</code></pre><p>需要在声明时指定所有依赖<br>CMD规范：</p>
<pre><code>define(<span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">require</span>,exports,<span class="keyword">module</span>)</span><span class="comment">{
    //...
}</span>);</span>
</code></pre><p>require,exports,module通过形参传递给模块，在需要依赖模块时，随时调用require()引用</p>
<p>兼容多种模块规范<br>将hello()方法定义到不同环境，兼容node，AMD，CMD及常见浏览器环境：</p>
<pre><code>;(<span class="function"><span class="keyword">function</span>(<span class="params">name,definition</span>)</span>{
    <span class="comment">//检测上下文环境是否为AMD或CMD</span>
    <span class="keyword">var</span> hasDefine = <span class="keyword">typeof</span> define === <span class="string">'function'</span>,
    <span class="comment">//检测上下文环境是否为node</span>
    hasExports = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports;
    <span class="keyword">if</span>(hasDefine){
          <span class="comment">//AMD环境或CMD环境</span>
          define(definition);
     }<span class="keyword">else</span> <span class="keyword">if</span>(hasExports){
          <span class="comment">//定义为普通node模块</span>
          <span class="built_in">module</span>.exports = definition();
     }<span class="keyword">else</span> {
          <span class="comment">//将模块执行结果挂在window变量中</span>
          <span class="keyword">this</span>[name] = definition();
     }
})(<span class="string">'hello'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{};
    <span class="keyword">return</span> hello;
});
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经验/">经验</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Jacy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>
title: 谈谈自家的许愿墙

tags: 经验

---

> 有个词语挺有意思的，叫老生常谈，顾名思议，老书生经常谈（虽然原意为老书生经常说的话），看来我也要成为老书生了，竟是谈~来回归正题，我们来谈谈自家的许愿墙。

## 项目背景
广工大学城校区是典型的阳盛阴衰的，每年的女生节在广工算是一个比较隆重的节目了吧，为了让女生享受到更加便利的关注，为了让更多的男生女生们参与进大学丰富多彩的活动中，许愿墙就诞生了，并传承至今。

## 项目简介
1.许愿墙在去年是开发成为微信的web app，相比往年增加了游戏这个新功能（虽然反响并不是特别好(┬＿┬)）。
2.我们团队先从项目需求入手进行分析，广工的背景让这个项目的生命周期在每年可以持续一周左右，除了提供基本的女生许愿男生领取愿望功能外，我们还希望加入一些新的元素吸引更多的人关注，类似接金币游戏就此诞生，画面展现出了男女生们的青春活力。
3.另外在这里不得不提提我们的暗恋匹配功能啦，大家写下心目中的他（她），若双方互相暗恋，就能告知对方，成就了数对小情侣们，成功牵线是我们的骄傲，是我们的自豪o(∩_∩)o。
4.考虑到保护女生们的信息安全问题，我们采取微信授权认证，只有男生领取了女生的愿望，才能获取女生相关信息，让他们能够进行交流而实现愿望。
5.项目在前端采用react+mobx+es6，引用gulp-webpack构建打包，后台使用nodejs+express构建，并使用mongo数据库存储相关信息数据（别想偷信息哈）。


## 技术介绍
### **前端**

**React：**
要问到前端方面为什么选用react呢，而不用轻量级vue和boss级angular呢，挑选技术栈时它们确实一直在向我们招手，都想要朕重用它们😄，vue虽然用的特别的舒服，style+template+javascript组成一个vue文件，每一个都那么的清晰，用的那么舒服，可是在前面做过几个项目都用的vue，这次我们想多接触下别的框架，扩宽知识广度，而angular相对比较适合大型应用，使用脏检测的方式跟踪更新数据，在不熟悉的情况下使用会有比较多的坑，因此我们还是选择了也比较热门的react进行开发。
react的virtual DOM（虚拟DOM）使得项目可以不用直接操作DOM，而是通过虚拟的DOM进行操作，然后经过改进的diff算法计算后，通过render函数进行更新，大大提高了项目的性能。
来来来，我们来了解了解react的virtual DOM是怎么回事，virtual DOM把原生的DOM进行了抽象，在生成页面的时候会同时产生原生DOM的副本，我们在js的操作是先对副本进行操作，然后使用diff算法对比，对发生变化的部分进行自动更新（也可以人为控制生命周期）而不用全部重新渲染。
传统的DOM diff算法是通过遍历节点实现的，算法复杂度达到了O(n^3)，指数型的算法复杂度在节点数多的时候效率是特别的低的，而react通过3个策略改进了diff算法，使其复杂度仅为O(n)，大大提高了计算速度。
**React diff策略：**

 1. 在web UI中DOM节点的跨层级操作是特别少的，基本可以忽略不计。
 2. 相同组件有相似的结构，不同组件有不同的结构。
 3. 对同一层次的节点可以通过唯一的id进行区分。

**第一点(tree diff)**
由于跨层级操作少，可以只对两棵树进行同层对比，当发现某一层次节点不存在或者新增了，则新增该节点或者删除该节点及其子节点（不会再对子节点进行比较）。
但是当出现跨层级的移动操作，React diff就会对已经不存在节点直接删除，而对新存在的节点进行新增，而不是直接通过移动实现，这样就会影响性能，所以还是需要尽量避免进行跨层级的操作。

**第二点(component diff)**
React diff在发现相同的组件时就会进行tree diff比较，而不同的组件则直接删除更换，不会再进行进一步的比较，这又通过节省diff计算大大提高了计算速度，当然用户可以通过shouldComponentUpdate()返回true还是false来自己决定是否对该组件及其子组件进行更新。

**第三点（element diff）**
React diff在同层次发现不同节点直接就删除替换了，那么有没可能只是顺序的不同，而只是调换一下顺序呢，当然有~
所以通过给节点标上唯一的id，那么节点就能通过对比新老集合的位置，只进行移动，而不需要进行删除及创建插入，这样就能更高效的进行更新了。

以上只是个人看了相关内容后的理解总结，有什么不对的可以评论改进喔~
在此留下收藏的资料供大家看：
[React源码解析+diff算法][1]
[github自己体会下diff算法（打开控制台观看）][2]

**mobx：**
对于mobx的了解倒还不是特别的深，稍微了解了下mobx和redux的区别，redux是有action，store和view三层，通过reducer修改数据后经过双向数据绑定达到更新试图的目的，但是redux会出现多订阅，粗粒度的缺点，比如：
if(c) {
    return a;
}
return b;
这时候会对a,b,c都进行监听，然而在c为true的时候，b就没有进行使用了；
粗粒度则是在只对arr[0].name进行了修改引用，而监听是针对的arr的；
由于许愿墙只需要进行store到view层的操作对使用的用户数据进行存储，因此采用mobx相对比较小，学习使用成本也相对比较低，通过es6的修饰器引入mobx的observable接口，在所有页面共享该用户的数据，减少各个页面对用户数据的传递导致组件的更新或者因此而导致的增加http请求。

**gulp-webpack:**
使用gulp进行本地的调试开发，自动更新页面大大提高了开发的效率，通过webpack引入css-loader、style-loader、url-loader分别对css的url进行支持，对css进行支持，对图片url进行支持，还引入postcss-loader（autoprefixer插件）自动增加css前缀适配多端，另外当然是引入babel-preset-es2015,babel-preset-react和babel-preset-stage-num(0~3)对es6进行解析。

### **后台**
后台使用nodejs+express框架开启服务器，通过express监听各个请求，设置路由专门处理相应的请求，另外在对数据库的操作再另外设置一个代理，路由中通过代理对数据库进行操作后作出请求的相应。
后台还需要通过引入bodyparser，cookieparser来对body json数据以及cookie进行解析使用。

## 问题汇总

1.首先感受最深刻的就是游戏性能问题的，由于首次接触canvas的游戏开发，对性能的研究基本没有，在掉落“金币”时的掉落动画会有些许卡顿，体验极其不友好。
**改进：**通过相关研究，在掉落“金币”时，对其对象进行重复利用，通过循环产生的“金币”，在经过下降后由于“金币”会消失在视图中，通过设置一定数量上限让“金币”达到上限时再重新从0开始赋予“金币”属性。

    function chansheng() {
        if (shi % h == 0) {
            for (var j = 2 * chi; j < 2 * (chi + 1); j++) {
                tu[j] = new object();
                ...
                var range = canvasW - w * B;
                var i = Math.round(Math.random() * range);
                if (j == 2 * chi + 1) {
                    while (Math.abs(i - tu[2 * chi].x) < w * B) {
                        i = Math.round(Math.random() * range);
                    }
                }
                tu[j].x = i;
                tu[j].y = -Math.round(Math.random() * 100);
            }
            chi++;
            if (chi == 50) chi = 0;  //重置数量
        }
        shi++;
    }

2.在性能的优化方面还有就是可以通过缓存图像进行提高性能。
**改进：**

    var cacheCanvas = [],
        cacheCtx = [],
        down = [];
    for (var i = 0; i <= 4; i++) {
        down[i] = new Image();
    }
    down[0].src = 'images/down/boy.png';
    down[1].src = 'images/down/+1s.png';
    down[2].src = 'images/down/+10KG.png';
    down[3].src = 'images/down/special.png';
    down[4].src = 'images/down/love.png';
    for (var i = 0; i <= 4; i++) {
        down[i].onload = function() {
            for (var i = 0; i <= 4; i++) {
                cacheCanvas[i] = document.createElement('canvas');  //创建多个canvas元素把图片预先缓存，需要时再取出
                cacheCtx[i] = cacheCanvas[i].getContext('2d');
                cacheCanvas[i].width = down[i].width * B;
                cacheCanvas[i].height = down[i].height * B;
                cacheCtx[i].drawImage(down[i], 0, 0, down[i].width * B, down[i].height * B)
            }
        }
    }

3.游戏在ios和安卓的适配方面出现了两个问题，一是在ios上iframe标签无法正常工作，二是ios9+的重力感应deviceorientation事件触发频率不同。
**改进：** iframe标签无法工作后统一使用外链的形式，由于男女进入的游戏是不同版本的，在react的jsx中先判断用户性别，后使用跳转的方式进入游戏。由于触发频率的不同，导致ios9+与其他用户的移动速度不同，ios9+会比较快，造成不公平现象，于是采用加入时间验证的方式使游戏相对公平。

    var timeControl = new Date();  //记录一次触发时间
    window.addEventListener("deviceorientation", function(event) {
        if (new Date() - timeControl >= 30) {   //时间相隔大于等于30ms再触发
            var move = event.gamma;
            if (move < 0) {
                sprite.x = sprite.x - moveSpeed;
            } else if (move > 0) {
                sprite.x = sprite.x + moveSpeed;
            }
            if (sprite.x + playerWidth >= canvasW) sprite.x = canvasW - playerWidth;
            else if (sprite.x <= 0) sprite.x = 0;
            timeControl = new Date(); //触发结束重置时间
        }
    }, true);

4.react的路由跳转问题，直接引用this.context.router.push(path)出错。
**改进：** 在react组件中需加入contextType对象。

    ComponentName.contextTypes = {
        router: React.propTypes.object.isRequired
    } //组件外加入的所以加上组件名字
    


  [1]: https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender
  [2]: https://supnate.github.io/react-dom-diff/index.html

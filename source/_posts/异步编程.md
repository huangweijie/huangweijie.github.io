title: 异步编程
tags: 经验
date: 2017-05-07
---

**偏函数用法**

    var toString = Object.prototype.toString;
    var isString = function (obj) {
        return toString.call(obj) == '[object String]';
    };
    var isFunction = function (obj) {
        return oString.call(obj) == '[object Function]';
    };

工厂模式：

    var isType = function (type) {
        return function (obj) {
            return toString.call(obj) == '[object ' + type + ']';
        };
    };
    var isString = isType('String');
    var isFunction = isType('Function');
    
**事件发布/订阅**

    //订阅
    emitter.on("evebt1",function (message) {
        console.log(message);
    });
    
    //发布
    emitter.emit('event1',"I am message!");
    
Node对事件发布/订阅机制做了额外处理：

1.如果对一个时间添加超过10个侦听器会得到一条警告。这跟Node自身单线程有关，设计者认为侦听器太多可能存在内存泄漏。调用emitter.setMaxListeners(0)可以将这个限制去掉。另外，由于事件发布会引起一系列侦听器执行，如果侦听器过多，可能过多占用CPU。
2.为处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加侦听器，若有则错误交给侦听器处理，否则抛出异常。如果外部没有捕获这个异常，将会引起线程退出。健壮的EventEmitter实例应对error事件做处理。

**继承events模块**

    var events = require('events');
    function Stream() {
        events.EventEmitter.call(this);
    }
    util.inherits(Stream, events.EventEmitter);(Node在util中封装了继承方法)

**EventProxy模块解决多异步之间的协作**

    var proxy = new EventProxy();
    proxy.all("template", "data", "resources", function (template, data, resources) {
        //TODO
    });
    fs.readFile(template_path, "utf8", function (err, template) {
        proxy.emit("template", template);
    });
    db.query(sql, function (err, data) {
        proxy.emit("data", data);
    });
    l10n.get(function (err, resources) {
        proxy.emit("resources", resources);
    });
EventProxy提供了一个all()方法来订阅多个事件，当每个事件都被触发后，侦听器才会执行一次。另外一个tail()是侦听器在满足条件时执行一次后，如果组合事件中的某个事件再次触发，侦听器会用最新数据继续执行。

**EventProxy的异常处理**

EventProxy提供了fail()和done()两个实例方法优化异常处理，使开发关注业务部分，而不是异常捕获上。
fail():

    ep.fail(callback);
    等价于：
    ep.fail(function (err) {
        callback(err);
    });
    等价于：
    ep.bind('error', function (err) {
        //卸载掉所有处理函数
        ep.unbind();
        //异常处理
        callback(err);
    });

done():
ep.done('tpl');
等价于：

    function (err, content) {
        if (err) {
            //一旦发生异常，交给error事件处理函数处理
            return ep.emit('error', err);
        }
        ep.emit('tpl', content);
    }
    
done()方法也接受一个函数作参数：

    ep.done(function (content) {
        //TODO
        //这里无需考虑异常
        ep.emit('tpl', content);
    });
    等价于：
    function (err, content) {
        if (err) {
            //一旦发生异常，交给error事件处理函数处理
            return ep.emit('error', err);
        }
        (function (content) {
            //TODO
            //这里无需考虑异常
            ep.emit('tpl', content);
        }(content));
    }
    
**then方法**

1.接受完成态、错误态的回调方法。
2.可选的支持progress事件回调作为第三个方法。
3.then()方法只接受function对象，其余对象被忽略。
4.then()方法继续返回Promise对象，实现链式调用。
then方法定义：
then(fulfilledHandler, errorHandler, progressHandler)

**以上为最为主流的模式：事件发布/订阅模式和Promise/Deferred模式**

### 非模式化应用
**尾触发和Next**
尾触发目前应用最多的地方是Connect的中间件
最简单的中间件：

    function(req请求对象, res响应对象, next尾触发函数){
        //中间件
    }
    
Connect的核心实现：

    function createServer () {
        function app(req, res){app.handle(req, res);}
        utils.merge(app, proto);
        utils.merge(app, EventEmitter.prototype);
        app.route = '/';
        app.stack = [];//核心，中间件队列
        for(var i = 0;i < arguments.length; i++){
            app.use(arguments[i]);
        }
        return app;
    };
    app.use = function(route, fn){
        // some code
        this.stack.push({ route: route, handle: fn});
        return this;
    }
    Node原声合同http模块实现监听：
    app.listen = function () {
        var server = http.createServer(this);
        return server.listen.apply(server, arguments);
    };
    处理每一个监听到的网络请求：
    app.handle = function(req, res, out){
        //some code
        next();
    }
    简化后的next():
    function next(err) {
        //some code
        //next callback
        layer = stack[index++];
        layer.handle(req, res, next);//传入next持续触发
    }
    
**流程控制模块async**
异步的串行执行：series()方法

    async.series([
        function(callback){
            fs.readFile('file1.txt','utf-8',callback);
        },
        function(callback){
            fa.readFile('file2.txt','utf-8',callback);
        }
    ],function(err, results) {
        //results => [file1.txt, file2.txt]
    });
    等价于：
    fs.readFile('file1.txt', 'utf-8', function(err, content){
        if (err) {
            return callback(err);
        }
        fs.readFile('file2.txt', 'utf-8', function(err, data) {
            if(err) {
                return callback(err);
            }
            callback(null, [content, data]);
        });
    });

异步的并行执行：parallel()方法

    async.parallel([
        function (callback) {
            fs.readFile('file1.txt', 'utf-8', callback);
        },
        function (callback) {
            fs.readFile('file2.txt', 'utf-8', callback);
        }
    ], function (err, results) {
        //results => [file1.txt, file2.txt]
    });
    等价于：
    var counter = 2;
    var results = [];
    var done = function (index, value){
        results[index] = value;
        counter--;
        if(counter === 0 ) {
            callback(null, results);
        }
    };
    //只传递第一个异常
    var hasErr = false;
    var fail = function (err) {
        if(!hasErr) {
            hasErr = true;
            callback(err);
        }
    };
    fs.readFile('file1.txt', 'utf-8', function (err, content) {
        if (err) {
            return fail(err);
        }
        done(0, content);
    });
    fs.readFile('file2.txt', 'utf-8', function (err, content) {
        if (err) {
            return fail(err);
        }
        done(1, data);
    });
